<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>Najeed's Car & Bike Info Website</title>
<style>
  body {
    margin: 0; padding: 0;
    font-family: 'Georgia', serif;
    background: url('https://images.pexels.com/photos/919073/pexels-photo-919073.jpeg') no-repeat center center fixed;
    background-size: cover;
    color: #f2f2f2;
  }
  body::before {
    content: '';
    position: fixed; top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0,0,0,0.5);
    z-index: -1;
  }
  header {
    position: fixed; top: 0; left: 0;
    width: 100%;
    height: 70px;
    background: rgba(0,0,0,0.7);
    display: flex;
    align-items: center;
    padding: 0 20px;
    box-sizing: border-box;
    z-index: 10000;
  }
  nav {
    display: flex;
    gap: 20px;
    flex: 1;
  }
  nav a {
    color: #f2f2f2;
    text-decoration: none;
    font-weight: 600;
    padding: 10px 15px;
    border-radius: 6px;
    user-select: none;
    transition: background-color 0.3s ease;
  }
  nav a:hover, nav a:focus {
    background-color: #8B5E3C;
    color: white;
    outline: none;
  }
  nav a[aria-current="page"] {
    background-color: #8B5E3C;
    cursor: default;
  }
  .search-container {
    position: relative;
    margin-left: 20px;
    display: flex;
    align-items: center;
  }
  .search-container input {
    padding: 8px 12px;
    border-radius: 5px;
    border: 2px solid #8B5E3C;
    font-size: 1rem;
    width: 200px;
    background-color: #2b2b2b;
    color: #f2f2f2;
    outline: none;
    transition: border-color 0.3s ease;
  }
  .search-container input::placeholder {
    color: #bba88d;
  }
  .search-container input:focus {
    border-color: #c49e65;
    background-color: #3c3c3c;
  }

  main {
    margin-top: 90px;
    max-width: 900px;
    margin-left: auto;
    margin-right: auto;
    background: rgba(0,0,0,0.6);
    border-radius: 10px;
    padding: 20px;
    box-sizing: border-box;
    color: #e0e0e0;
    user-select: none;
  }

  #gameContainer {
    position: relative;
    margin-top: 20px;
    text-align: center;
  }
  #gameCanvas {
    background: #555;
    border-radius: 10px;
    margin: 0 auto;
    display: block;
    touch-action: none;
  }
  #playPauseBtn {
    margin: 10px auto 0;
    display: block;
    padding: 10px 25px;
    font-size: 1.2rem;
    cursor: pointer;
    background: #8B5E3C;
    border: none;
    border-radius: 8px;
    color: white;
    user-select: none;
    transition: background-color 0.3s ease;
  }
  #playPauseBtn:hover {
    background: #b2854d;
  }
  #score, #highScore {
    color: #c49e65;
    font-size: 1.3rem;
    font-weight: bold;
    margin-top: 8px;
  }
  #gameOverMessage {
    position: absolute;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(255,0,0,0.85);
    color: white;
    padding: 20px 40px;
    border-radius: 12px;
    font-size: 1.8rem;
    font-weight: bold;
    display: none;
    text-align: center;
    user-select: none;
    width: 90%;
    max-width: 350px;
    z-index: 10001;
  }

  /* Mobile controls */
  #mobileControls {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 20px;
    user-select: none;
    z-index: 10002;
  }
  #mobileControls button {
    font-size: 3rem; /* bigger buttons */
    padding: 15px 30px;
    border-radius: 12px;
    border: none;
    background-color: #8B5E3C;
    color: white;
    cursor: pointer;
    user-select: none;
    transition: background-color 0.3s ease;
  }
  #mobileControls button:active {
    background-color: #b2854d;
  }

  /* Responsive canvas size */
  @media (max-width: 600px) {
    #gameCanvas {
      width: 100% !important;
      height: auto !important;
    }
  }
</style>
</head>
<body>

<header>
  <nav role="navigation" aria-label="Main Navigation">
    <a href="index.html" aria-current="page">Home</a>
    <a href="contact.html">Contact</a>
    <a href="about.html">About</a>
    <a href="about-cars.html">About Cars</a>
  </nav>

  <div class="search-container" role="search">
    <form onsubmit="return doSearch(event)">
      <input type="text" id="searchQuery" placeholder="Search the car or bike..." aria-label="Search the car or bike" />
    </form>
  </div>
</header>

<main>
  <!-- Removed game instructions per your request -->

  <div id="gameContainer" role="main" aria-label="Car game">
    <button id="playPauseBtn" aria-pressed="false" aria-label="Start or pause game">Play</button>
    <canvas id="gameCanvas" width="500" height="300" aria-label="Simple car game"></canvas>
    <div id="gameOverMessage" aria-hidden="true">Game Over!<br>Click Retry to play again.</div>
    <div id="score" aria-live="polite">Score: 0</div>
    <div id="highScore" aria-live="polite">High Score: 0</div>
  </div>

  <div id="mobileControls" aria-label="Mobile game controls">
    <button id="leftBtn" aria-label="Move car left">◀️</button>
    <button id="rightBtn" aria-label="Move car right">▶️</button>
  </div>
</main>

<script>
  // Search function
  function doSearch(event) {
    event.preventDefault();
    const query = document.getElementById('searchQuery').value.trim();
    if (query) {
      window.open('https://www.google.com/search?q=' + encodeURIComponent(query), '_blank');
    }
  }

  // Game variables & constants
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  // Responsive adjustments
  const isMobile = window.matchMedia("(max-width: 600px)").matches;

  // Sizes
  const lanesCount = 3;
  let carWidth = isMobile ? 30 : 50;
  let carHeight = isMobile ? 50 : 80;
  let enemyWidth = isMobile ? 30 : 50;
  let enemyHeight = isMobile ? 50 : 80;

  // Lanes X positions calculated dynamically based on canvas width
  const lanesX = [];
  function calculateLanesX() {
    lanesX.length = 0;
    const laneWidth = canvas.width / lanesCount;
    for (let i = 0; i < lanesCount; i++) {
      // Center car in lane
      lanesX.push(i * laneWidth + (laneWidth - carWidth) / 2);
    }
  }
  calculateLanesX();

  // Car position & movement
  let currentLane = 1; // Start middle lane
  let targetLane = 1;
  let carY = canvas.height - carHeight - 20;
  let carBounce = 0;
  let wheelRotation = 0;

  // Enemy cars
  let enemyCars = [];
  let enemySpeed = 2;
  let enemySpawnRate = 0.01;

  // Power-ups
  let powerUps = [];
  let powerUpSpawnRate = 0.002;
  const powerUpSize = isMobile ? 20 : 30;

  // Game state
  let score = 0;
  let highScore = localStorage.getItem('carGameHighScore') || 0;
  let scoreMultiplier = 1;
  let level = 1;
  let framesElapsed = 0;
  let isPlaying = false;
  let paused = false;
  let gameOverFlag = false;
  let countdownActive = false;
  let shieldActive = false;
  let speedBoostActive = false;
  let shieldTimer = 0;
  let speedBoostTimer = 0;
  let muted = false;

  // DOM Elements
  const playPauseBtn = document.getElementById('playPauseBtn');
  const scoreDisplay = document.getElementById('score');
  const highScoreDisplay = document.getElementById('highScore');
  const gameOverMessage = document.getElementById('gameOverMessage');
  const mobileControls = document.getElementById('mobileControls');
  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');

  // Sounds
  const sounds = {
    leftRight: new Audio('https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg'),
    gameStart: new Audio('https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg'),
    crash1: new Audio('https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg'),
    crash2: new Audio('https://actions.google.com/sounds/v1/cartoon/pop.ogg'),
    powerUp: new Audio('https://actions.google.com/sounds/v1/cartoon/slide_whistle_to_drum_hit.ogg'),
    shieldOn: new Audio('https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg'),
    carEngine: new Audio('https://actions.google.com/sounds/v1/transportation/car_accelerate.ogg'),
    backgroundMusic: new Audio('https://actions.google.com/sounds/v1/ambiences/forest_rain.ogg'),
  };
  sounds.carEngine.loop = true;
  sounds.backgroundMusic.loop = true;

  function playSound(sound) {
    if (!muted) {
      sound.currentTime = 0;
      sound.play().catch(() => {});
    }
  }

  // Keyboard controls
  window.addEventListener('keydown', e => {
    if (!isPlaying || paused) return;
    if (e.key === 'ArrowLeft' && targetLane > 0) {
      targetLane--;
      playSound(sounds.leftRight);
    }
    if (e.key === 'ArrowRight' && targetLane < lanesCount - 1) {
      targetLane++;
      playSound(sounds.leftRight);
    }
  });

  // Mobile buttons
  leftBtn.addEventListener('touchstart', e => {
    e.preventDefault();
    if (!isPlaying || paused) return;
    if (targetLane > 0) {
      targetLane--;
      playSound(sounds.leftRight);
    }
  });
  rightBtn.addEventListener('touchstart', e => {
    e.preventDefault();
    if (!isPlaying || paused) return;
    if (targetLane < lanesCount - 1) {
      targetLane++;
      playSound(sounds.leftRight);
    }
  });

  // Responsive canvas resize on window resize (only width)
  function resizeCanvas() {
    const containerWidth = Math.min(window.innerWidth - 40, 600);
    canvas.width = containerWidth;
    canvas.height = containerWidth * 0.6; // Keep aspect ratio 5:3
    carY = canvas.height - carHeight - 20;
    calculateLanesX();
  }
  window.addEventListener('resize', () => {
    resizeCanvas();
  });
  resizeCanvas();

  // Draw road with lane dividers
  function drawRoad() {
    ctx.fillStyle = '#555';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Side lines
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.moveTo(10, 0);
    ctx.lineTo(10, canvas.height);
    ctx.moveTo(canvas.width - 10, 0);
    ctx.lineTo(canvas.width - 10, canvas.height);
    ctx.stroke();

    // Lane dividers (dashed)
    const laneWidth = canvas.width / lanesCount;
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 3;
    ctx.setLineDash([20, 20]);
    for (let i = 1; i < lanesCount; i++) {
      const x = i * laneWidth;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvas.height);
      ctx.stroke();
    }
    ctx.setLineDash([]);
  }

  // Draw car with shadow, gradient, rotating wheels & bounce effect
  function drawCar() {
    const x = lanesX[currentLane] + carBounce;
    const y = carY;

    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,0.7)';
    ctx.shadowBlur = 8;
    ctx.shadowOffsetX = 3;
    ctx.shadowOffsetY = 5;

    const grad = ctx.createLinearGradient(x, y, x, y + carHeight);
    grad.addColorStop(0, '#d32f2f');
    grad.addColorStop(1, '#8b0000');
    ctx.fillStyle = grad;
    ctx.fillRect(x, y, carWidth, carHeight);

    ctx.restore();

    ctx.fillStyle = '#87ceeb';
    ctx.fillRect(x + 10, y + 10, carWidth - 20, carHeight / 3);

    const wheelRadiusX = 8;
    const wheelRadiusY = 12;
    const wheelY = y + carHeight - 15;

    ctx.fillStyle = 'black';
    ctx.save();
    ctx.translate(x + 12, wheelY);
    ctx.rotate(wheelRotation);
    ctx.beginPath();
    ctx.ellipse(0, 0, wheelRadiusX, wheelRadiusY, 0, 0, 2 * Math.PI);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.translate(x + carWidth - 12, wheelY);
    ctx.rotate(wheelRotation);
    ctx.beginPath();
    ctx.ellipse(0, 0, wheelRadiusX, wheelRadiusY, 0, 0, 2 * Math.PI);
    ctx.fill();
    ctx.restore();

    if (shieldActive) {
      ctx.save();
      ctx.strokeStyle = 'cyan';
      ctx.lineWidth = 6;
      ctx.shadowColor = 'cyan';
      ctx.shadowBlur = 15;
      ctx.strokeRect(x - 5, y - 5, carWidth + 10, carHeight + 10);
      ctx.restore();
    }
  }

  // Draw enemy car with shadow, gradient & rotating wheels
  function drawEnemyCar(enemy) {
    const x = lanesX[enemy.lane];
    const y = enemy.y;

    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,0.7)';
    ctx.shadowBlur = 8;
    ctx.shadowOffsetX = 3;
    ctx.shadowOffsetY = 5;

    const grad = ctx.createLinearGradient(x, y, x, y + enemyHeight);
    grad.addColorStop(0, '#1565c0');
    grad.addColorStop(1, '#003c8f');
    ctx.fillStyle = grad;
    ctx.fillRect(x, y, enemyWidth, enemyHeight);

    ctx.restore();

    ctx.fillStyle = '#90caf9';
    ctx.fillRect(x + 10, y + 10, enemyWidth - 20, enemyHeight / 3);

    const wheelRadiusX = 8;
    const wheelRadiusY = 12;
    const wheelY = y + enemyHeight - 15;

    ctx.fillStyle = 'black';
    ctx.save();
    ctx.translate(x + 12, wheelY);
    ctx.rotate(wheelRotation);
    ctx.beginPath();
    ctx.ellipse(0, 0, wheelRadiusX, wheelRadiusY, 0, 0, 2 * Math.PI);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.translate(x + enemyWidth - 12, wheelY);
    ctx.rotate(wheelRotation);
    ctx.beginPath();
    ctx.ellipse(0, 0, wheelRadiusX, wheelRadiusY, 0, 0, 2 * Math.PI);
    ctx.fill();
    ctx.restore();
  }

  // Collision check
  function isColliding(r1, r2) {
    return !(r1.x > r2.x + r2.width ||
             r1.x + r1.width < r2.x ||
             r1.y > r2.y + r2.height ||
             r1.y + r1.height < r2.y);
  }

  // Spawn enemy car in random lane
  function spawnEnemy() {
    const lane = Math.floor(Math.random() * lanesCount);
    enemyCars.push({ lane, y: -enemyHeight });
  }

  // Spawn power-up in random lane
  function spawnPowerUp() {
    const lane = Math.floor(Math.random() * lanesCount);
    const type = Math.random() < 0.5 ? 'shield' : 'speed';
    powerUps.push({ lane, y: -powerUpSize, type });
  }

  // Update enemies position, remove off screen, increase score
  function updateEnemies() {
    for (let i = enemyCars.length - 1; i >= 0; i--) {
      enemyCars[i].y += enemySpeed;
      if (enemyCars[i].y > canvas.height) {
        enemyCars.splice(i, 1);
        if (!speedBoostActive) score += 1 * scoreMultiplier;
        else score += 2 * scoreMultiplier;
      }
    }
  }

  // Update power-ups position, remove off screen, check collision
  function updatePowerUps() {
    for (let i = powerUps.length - 1; i >= 0; i--) {
      powerUps[i].y += enemySpeed;
      if (powerUps[i].y > canvas.height) {
        powerUps.splice(i, 1);
        continue;
      }

      // Check collision with player car
      const playerRect = {
        x: lanesX[currentLane],
        y: carY,
        width: carWidth,
        height: carHeight
      };
      const powerUpRect = {
        x: lanesX[powerUps[i].lane],
        y: powerUps[i].y,
        width: powerUpSize,
        height: powerUpSize
      };

      if (isColliding(playerRect, powerUpRect)) {
        // Activate power-up
        if (powerUps[i].type === 'shield') {
          shieldActive = true;
          shieldTimer = 600; // lasts 10 seconds at 60fps
          playSound(sounds.shieldOn);
        } else if (powerUps[i].type === 'speed') {
          speedBoostActive = true;
          speedBoostTimer = 600;
          playSound(sounds.powerUp);
        }
        powerUps.splice(i, 1);
      }
    }
  }

  // Draw power-ups
  function drawPowerUps() {
    powerUps.forEach(pu => {
      const x = lanesX[pu.lane] + (carWidth - powerUpSize) / 2;
      const y = pu.y;

      if (pu.type === 'shield') {
        ctx.fillStyle = 'cyan';
      } else {
        ctx.fillStyle = 'gold';
      }
      ctx.beginPath();
      ctx.arc(x + powerUpSize/2, y + powerUpSize/2, powerUpSize/2, 0, 2 * Math.PI);
      ctx.fill();
    });
  }

  // Level up notification
  let levelUpTimer = 0;
  function showLevelUp() {
    ctx.save();
    ctx.font = 'bold 40px Georgia';
    ctx.fillStyle = 'gold';
    ctx.textAlign = 'center';
    ctx.shadowColor = 'rgba(255,215,0,0.7)';
    ctx.shadowBlur = 20;
    ctx.fillText('Level ' + level + '!', canvas.width / 2, canvas.height / 2);
    ctx.restore();
  }

  // Game loop
  function gameLoop() {
    if (!isPlaying || paused) return;

    framesElapsed++;

    // Increase difficulty every 10 seconds (~600 frames)
    if (framesElapsed % 600 === 0) {
      level++;
      enemySpeed += 0.5;
      enemySpawnRate += 0.005;
      if (enemySpawnRate > 0.15) enemySpawnRate = 0.15;
      scoreMultiplier = 1 + level * 0.1;
      levelUpTimer = 180; // show level up for 3 seconds
    }

    if (levelUpTimer > 0) levelUpTimer--;

    // Spawn enemies and power-ups randomly
    if (Math.random() < enemySpawnRate) spawnEnemy();
    if (Math.random() < powerUpSpawnRate) spawnPowerUp();

    // Move car towards target lane smoothly
    if (currentLane < targetLane) {
      currentLane += 0.05;
      if (currentLane > targetLane) currentLane = targetLane;
    } else if (currentLane > targetLane) {
      currentLane -= 0.05;
      if (currentLane < targetLane) currentLane = targetLane;
    }

    // Bounce effect on car position for animation
    carBounce = Math.sin(framesElapsed * 0.3) * 2;
    wheelRotation += 0.3;

    // Update enemy & power-ups positions
    updateEnemies();
    updatePowerUps();

    // Check collisions with enemies
    const playerRect = {
      x: lanesX[Math.round(currentLane)],
      y: carY,
      width: carWidth,
      height: carHeight
    };
    for (let enemy of enemyCars) {
      const enemyRect = {
        x: lanesX[enemy.lane],
        y: enemy.y,
        width: enemyWidth,
        height: enemyHeight
      };

      if (isColliding(playerRect, enemyRect)) {
        if (shieldActive) {
          shieldActive = false;
          shieldTimer = 0;
          // Bounce car back a bit on hit with shield
          playSound(sounds.crash2);
          carBounce = -15;
          enemy.y = canvas.height + 100; // remove enemy by pushing offscreen
        } else {
          endGame();
          return;
        }
      }
    }

    // Power-up timers
    if (shieldActive) {
      shieldTimer--;
      if (shieldTimer <= 0) shieldActive = false;
    }
    if (speedBoostActive) {
      speedBoostTimer--;
      if (speedBoostTimer <= 0) speedBoostActive = false;
    }

    // Clear canvas & redraw
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawRoad();
    drawPowerUps();
    drawCar();
    enemyCars.forEach(drawEnemyCar);

    // Draw score and high score
    scoreDisplay.textContent = 'Score: ' + Math.floor(score);
    if (score > highScore) {
      highScore = Math.floor(score);
      localStorage.setItem('carGameHighScore', highScore);
    }
    highScoreDisplay.textContent = 'High Score: ' + highScore;

    // Level up notification display
    if (levelUpTimer > 0) {
      showLevelUp();
    }

    requestAnimationFrame(gameLoop);
  }

  // Game control functions
  function startGame() {
    if (countdownActive) return;
    countdownActive = true;
    playPauseBtn.disabled = true;
    let count = 3;
    playPauseBtn.textContent = count;

    const countdownInterval = setInterval(() => {
      count--;
      if (count > 0) {
        playPauseBtn.textContent = count;
        playSound(sounds.gameStart);
      } else {
        clearInterval(countdownInterval);
        playPauseBtn.textContent = 'Pause';
        isPlaying = true;
        paused = false;
        countdownActive = false;
        framesElapsed = 0;
        score = 0;
        enemySpeed = 2;
        enemySpawnRate = 0.01;
        level = 1;
        scoreMultiplier = 1;
        enemyCars = [];
        powerUps = [];
        shieldActive = false;
        speedBoostActive = false;
        shieldTimer = 0;
        speedBoostTimer = 0;
        gameOverFlag = false;
        playPauseBtn.disabled = false;
        sounds.backgroundMusic.play().catch(() => {});
        sounds.carEngine.play().catch(() => {});
        gameLoop();
      }
    }, 1000);
  }

  function pauseGame() {
    if (!isPlaying) return;
    paused = true;
    isPlaying = false;
    playPauseBtn.textContent = 'Play';
    playPauseBtn.setAttribute('aria-pressed', 'false');
    sounds.carEngine.pause();
    sounds.backgroundMusic.pause();
  }

  function resumeGame() {
    if (!paused) return;
    paused = false;
    isPlaying = true;
    playPauseBtn.textContent = 'Pause';
    playPauseBtn.setAttribute('aria-pressed', 'true');
    sounds.carEngine.play();
    sounds.backgroundMusic.play();
    gameLoop();
  }

  function resetGame() {
    score = 0;
    enemySpeed = 2;
    enemySpawnRate = 0.01;
    framesElapsed = 0;
    level = 1;
    scoreMultiplier = 1;
    enemyCars = [];
    powerUps = [];
    shieldActive = false;
    speedBoostActive = false;
    shieldTimer = 0;
    speedBoostTimer = 0;
    currentLane = 1;
    targetLane = 1;
    gameOverFlag = false;
    paused = false;
    isPlaying = false;
    countdownActive = false;
    playPauseBtn.textContent = 'Play';
    playPauseBtn.disabled = false;
    gameOverMessage.style.display = 'none';
    scoreDisplay.textContent = 'Score: 0';
    highScoreDisplay.textContent = 'High Score: ' + highScore;
    sounds.carEngine.pause();
    sounds.carEngine.currentTime = 0;
    sounds.backgroundMusic.pause();
    sounds.backgroundMusic.currentTime = 0;
  }

  function endGame() {
    isPlaying = false;
    paused = false;
    gameOverFlag = true;
    gameOverMessage.style.display = 'block';
    playPauseBtn.textContent = 'Retry';
    sounds.carEngine.pause();
    sounds.carEngine.currentTime = 0;
    sounds.backgroundMusic.pause();
    sounds.backgroundMusic.currentTime = 0;
    // Play random crash sound
    const crashSound = Math.random() < 0.5 ? sounds.crash1 : sounds.crash2;
    playSound(crashSound);
    // Mobile vibration on crash (if supported)
    if (navigator.vibrate) {
      navigator.vibrate([200, 100, 200]);
    }
  }

  // Play/pause button handler
  playPauseBtn.addEventListener('click', () => {
    if (gameOverFlag) {
      resetGame();
      startGame();
    } else if (!isPlaying && !paused) {
      startGame();
      playPauseBtn.setAttribute('aria-pressed', 'true');
    } else if (isPlaying) {
      pauseGame();
    } else if (paused) {
      resumeGame();
      playPauseBtn.setAttribute('aria-pressed', 'true');
    }
  });

  // Mute/unmute with keyboard 'M' key (optional)
  window.addEventListener('keydown', e => {
    if (e.key.toLowerCase() === 'm') {
      muted = !muted;
      if (muted) {
        sounds.carEngine.pause();
        sounds.backgroundMusic.pause();
      } else if (isPlaying) {
        sounds.carEngine.play();
        sounds.backgroundMusic.play();
      }
    }
  });

  // Initialize UI with high score
  highScoreDisplay.textContent = 'High Score: ' + highScore;

  // Initial reset
  resetGame();
</script>

</body>
</html>
