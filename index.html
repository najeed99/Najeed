<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Najeed's Car & Bike Info Website</title>
<style>
  body {
    margin: 0; padding: 0;
    font-family: 'Georgia', serif;
    background: url('https://images.pexels.com/photos/919073/pexels-photo-919073.jpeg') no-repeat center center fixed;
    background-size: cover;
    color: #f2f2f2;
  }
  body::before {
    content: '';
    position: fixed; top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0,0,0,0.5);
    z-index: -1;
  }
  header {
    position: fixed; top: 0; left: 0;
    width: 100%;
    height: 70px;
    background: rgba(0,0,0,0.7);
    display: flex;
    align-items: center;
    padding: 0 20px;
    box-sizing: border-box;
    z-index: 10000;
  }
  nav {
    display: flex;
    gap: 20px;
    flex: 1;
  }
  nav a {
    color: #f2f2f2;
    text-decoration: none;
    font-weight: 600;
    padding: 10px 15px;
    border-radius: 6px;
    user-select: none;
    transition: background-color 0.3s ease;
  }
  nav a:hover, nav a:focus {
    background-color: #8B5E3C;
    color: white;
    outline: none;
  }
  nav a[aria-current="page"] {
    background-color: #8B5E3C;
    cursor: default;
  }
  .search-container {
    position: relative;
    margin-left: 20px;
    display: flex;
    align-items: center;
  }
  .search-container input {
    padding: 8px 12px;
    border-radius: 5px;
    border: 2px solid #8B5E3C;
    font-size: 1rem;
    width: 200px;
    background-color: #2b2b2b;
    color: #f2f2f2;
    outline: none;
    transition: border-color 0.3s ease;
  }
  .search-container input::placeholder {
    color: #bba88d;
  }
  .search-container input:focus {
    border-color: #c49e65;
    background-color: #3c3c3c;
  }

  main {
    margin-top: 90px;
    max-width: 900px;
    margin-left: auto;
    margin-right: auto;
    background: rgba(0,0,0,0.6);
    border-radius: 10px;
    padding: 20px;
    box-sizing: border-box;
    color: #e0e0e0;
    user-select: none;
  }

  #gameContainer {
    position: relative;
    margin-top: 20px;
    max-width: 300px;
    margin-left: auto;
    margin-right: auto;
  }
  #gameCanvas {
    background: #555;
    border-radius: 10px;
    display: block;
    margin: 0 auto;
    touch-action: none;
    width: 300px;
    height: 500px;
  }
  #playPauseBtn {
    margin: 10px auto 0;
    display: block;
    padding: 10px 25px;
    font-size: 1.2rem;
    cursor: pointer;
    background: #8B5E3C;
    border: none;
    border-radius: 8px;
    color: white;
    user-select: none;
    transition: background-color 0.3s ease;
  }
  #playPauseBtn:hover {
    background: #b2854d;
  }
  #score, #highScore {
    color: #c49e65;
    font-size: 1.3rem;
    font-weight: bold;
    margin-top: 8px;
    text-align: center;
  }
  #highScore {
    margin-bottom: 4px;
  }
  #gameOverMessage, #levelUpMessage, #pauseOverlay {
    position: absolute;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    padding: 20px 40px;
    border-radius: 12px;
    font-size: 1.8rem;
    font-weight: bold;
    display: none;
    text-align: center;
    user-select: none;
    width: 90%;
    max-width: 350px;
    background: rgba(255,0,0,0.85);
  }
  #levelUpMessage {
    background: rgba(139,94,60,0.9);
    top: 35%;
    font-size: 2rem;
  }
  #pauseOverlay {
    background: rgba(0,0,0,0.85);
    font-size: 2rem;
  }

    /* Mobile controls */
  #mobileControls {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 12px;
    user-select: none;
    z-index: 10001;
  }
  #mobileControls button {
    font-size: 1.8rem;       /* choto font size */
    padding: 8px 14px;       /* choto padding */
    border-radius: 10px;
    border: none;
    background-color: #8B5E3C;
    color: white;
    cursor: pointer;
    user-select: none;
    min-width: 40px;         /* choto min width */
    height: 48px;            /* height set korlam */
    text-align: center;
  }
  #mobileControls button:active {
    background-color: #b2854d;
  }

  /* Hide mobile controls on desktop */
  @media(min-width: 600px) {
    #mobileControls {
      display: none !important;
    }
  }
</style>
</head>
<body>

<header>
  <nav role="navigation" aria-label="Main Navigation">
    <a href="index.html" aria-current="page">Home</a>
    <a href="contact.html">Contact</a>
    <a href="about.html">About</a>
    <a href="about-cars.html">About Cars</a>
  </nav>

  <div class="search-container" role="search">
    <form onsubmit="return doSearch(event)">
      <input type="text" id="searchQuery" placeholder="Search the car or bike..." aria-label="Search the car or bike" />
    </form>
  </div>
</header>

<main>
  <h2>Welcome to Najeed's Car & Bike Info Website</h2>
  <p>Stay updated with the latest news, specifications, and reviews about cars and bikes. Play our simple car game below to enjoy some fun while you browse!</p>

  <div id="gameContainer" aria-live="polite" aria-label="Car game container">
    <button id="playPauseBtn" aria-label="Play or pause the game">Play</button>
    <canvas id="gameCanvas" width="300" height="500" aria-label="Simple car game"></canvas>
    <div id="gameOverMessage" role="alert">Game Over!<br>Click Retry to play again.</div>
    <div id="levelUpMessage" aria-live="polite">Level Up!</div>
    <div id="pauseOverlay" role="alert">Paused</div>
    <div id="score" aria-live="polite">Score: 0</div>
    <div id="highScore" aria-live="polite">High Score: 0</div>
  </div>

  <div id="mobileControls" aria-label="Mobile game controls">
    <button id="leftBtn" aria-label="Move car left">â—€</button>
    <button id="rightBtn" aria-label="Move car right">â–¶</button>
    <button id="muteBtn" aria-label="Mute or unmute sound">ðŸ”ˆ</button>
  </div>
</main>

<script>
  // Search function
  function doSearch(event){
    event.preventDefault();
    const query = document.getElementById('searchQuery').value.trim();
    if(query) {
      window.open('https://www.google.com/search?q=' + encodeURIComponent(query), '_blank');
    }
  }

  // Sounds
  const sounds = {
    leftRight: new Audio('https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg'),
    gameStart: new Audio('https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg'),
    gameOver: new Audio('https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg'),
    shieldOn: new Audio('https://actions.google.com/sounds/v1/cartoon/clang.ogg'),
    powerUp: new Audio('https://actions.google.com/sounds/v1/cartoon/pop.ogg'),
    backgroundMusic: new Audio('https://actions.google.com/sounds/v1/ambiences/traffic.ogg'),
    countdownBeep: new Audio('https://actions.google.com/sounds/v1/cartoon/clang.ogg'),
  };
  sounds.backgroundMusic.loop = true;

  let muted = false;
  function playSound(sound){
    if(!muted){
      sound.currentTime = 0;
      sound.play();
    }
  }

  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  const lanesCount = 3;
  const laneWidth = canvas.width / lanesCount;
  const carWidth = 45;
  const carHeight = 75;
  const enemyWidth = 45;
  const enemyHeight = 75;
  const powerUpSize = 30;

  // Lane X positions for cars (centered in lane)
  const lanesX = [
    laneWidth * 0.5 - carWidth / 2,
    laneWidth * 1.5 - carWidth / 2,
    laneWidth * 2.5 - carWidth / 2
  ];

  // Player car position state
  let currentLane = 1; // middle lane start
  let targetLane = 1;
  let carX = lanesX[currentLane];
  const carY = canvas.height - carHeight - 20;

  // Game variables
  let enemyCars = [];
  let powerUps = [];
  let enemySpeed = 1.5;
  let enemySpawnRate = 0.008;
  let powerUpSpawnRate = 0.004;

  let score = 0;
  let scoreMultiplier = 1;
  let maxMultiplier = 3;
  let framesElapsed = 0;
  let isPlaying = false;
  let gameOverFlag = false;
  let paused = false;

  // Power-up states
  let shieldActive = false;
  let shieldTimer = 0;
  let speedBoostActive = false;
  let speedBoostTimer = 0;

  // Visuals
  let wheelRotation = 0;
  let carBounce = 0;

  // HTML elements
  const playPauseBtn = document.getElementById('playPauseBtn');
  const scoreDisplay = document.getElementById('score');
  const highScoreDisplay = document.getElementById('highScore');
  const gameOverMessage = document.getElementById('gameOverMessage');
  const levelUpMessage = document.getElementById('levelUpMessage');
  const pauseOverlay = document.getElementById('pauseOverlay');
  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const muteBtn = document.getElementById('muteBtn');

  // Load high score from localStorage
  let highScore = 0;
  try {
    const storedScore = localStorage.getItem('carGameHighScore');
    if(storedScore !== null){
      const parsed = parseInt(storedScore);
      if(!isNaN(parsed)) highScore = parsed;
    }
  } catch(e) {
    highScore = 0;
  }
  highScoreDisplay.textContent = `High Score: ${highScore}`;

  // Input states
  let leftPressed = false;
  let rightPressed = false;

  // Keyboard control
  window.addEventListener('keydown', e => {
    if(e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a'){
      leftPressed = true;
      playSound(sounds.leftRight);
    } else if(e.key === 'ArrowRight' || e.key.toLowerCase() === 'd'){
      rightPressed = true;
      playSound(sounds.leftRight);
    } else if(e.key.toLowerCase() === 'p'){
      if(isPlaying) pauseGame();
      else startGame();
    } else if(e.key.toLowerCase() === 'm'){
      toggleMute();
    }
  });
  window.addEventListener('keyup', e => {
    if(e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a'){
      leftPressed = false;
    } else if(e.key === 'ArrowRight' || e.key.toLowerCase() === 'd'){
      rightPressed = false;
    }
  });

  // Mobile touch controls
  leftBtn.addEventListener('touchstart', e => {
    e.preventDefault();
    leftPressed = true;
    playSound(sounds.leftRight);
  });
  leftBtn.addEventListener('touchend', e => {
    e.preventDefault();
    leftPressed = false;
  });
  rightBtn.addEventListener('touchstart', e => {
    e.preventDefault();
    rightPressed = true;
    playSound(sounds.leftRight);
  });
  rightBtn.addEventListener('touchend', e => {
    e.preventDefault();
    rightPressed = false;
  });
  muteBtn.addEventListener('click', () => {
    toggleMute();
  });

  // Hide mobile controls on desktop
  function checkMobileControls(){
    if(window.innerWidth >= 600){
      document.getElementById('mobileControls').style.display = 'none';
    } else {
      document.getElementById('mobileControls').style.display = 'flex';
    }
  }
  window.addEventListener('resize', checkMobileControls);
  checkMobileControls();

  playPauseBtn.addEventListener('click', () => {
    if(gameOverFlag){
      resetGame();
      startGame();
      requestAnimationFrame(gameLoop);
    } else {
      if(isPlaying) pauseGame();
      else {
        startGame();
        requestAnimationFrame(gameLoop);
      }
    }
  });

  function toggleMute(){
    muted = !muted;
    muteBtn.textContent = muted ? 'ðŸ”‡' : 'ðŸ”ˆ';
    if(muted){
      sounds.backgroundMusic.pause();
    } else if(isPlaying){
      sounds.backgroundMusic.play();
    }
  }
  muteBtn.textContent = muted ? 'ðŸ”‡' : 'ðŸ”ˆ';

  // Road drawing with lane dividers
  function drawRoad(){
    ctx.fillStyle = '#555';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.strokeStyle = 'white';
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(10, 0);
    ctx.lineTo(10, canvas.height);
    ctx.moveTo(canvas.width - 10, 0);
    ctx.lineTo(canvas.width - 10, canvas.height);
    ctx.stroke();

    ctx.strokeStyle = 'white';
    ctx.lineWidth = 4;
    ctx.setLineDash([30, 30]);
    for(let i=1; i<lanesCount; i++){
      const x = i * laneWidth;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvas.height);
      ctx.stroke();
    }
    ctx.setLineDash([]);
  }

  // Draw the player car with gradient, wheels, and bounce effect
  function drawCar() {
    const x = carX;
    const y = carY + (carBounce > 0 ? Math.sin(carBounce/2) * 5 : 0);

    const grad = ctx.createLinearGradient(x, y, x, y + carHeight);
    grad.addColorStop(0, '#d32f2f');
    grad.addColorStop(1, '#7b0000');
    ctx.fillStyle = grad;
    ctx.fillRect(x, y, carWidth, carHeight);

    ctx.fillStyle = '#87ceeb';
    ctx.fillRect(x + 10, y + 10, carWidth - 20, carHeight / 3);

    // Wheels with rotation
    ctx.fillStyle = 'black';
    ctx.save();
    ctx.translate(x + 15, y + carHeight - 20);
    ctx.rotate(wheelRotation);
    ctx.beginPath();
    ctx.ellipse(0, 0, 8, 12, 0, 0, 2 * Math.PI);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.translate(x + carWidth - 15, y + carHeight - 20);
    ctx.rotate(wheelRotation);
    ctx.beginPath();
    ctx.ellipse(0, 0, 8, 12, 0, 0, 2 * Math.PI);
    ctx.fill();
    ctx.restore();

    if(shieldActive){
      ctx.strokeStyle = 'cyan';
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.arc(x + carWidth/2, y + carHeight/2, carWidth, 0, 2*Math.PI);
      ctx.stroke();
    }
  }

  // Draw enemy cars
  function drawEnemyCar(enemy) {
    const x = lanesX[enemy.lane];
    const y = enemy.y;

    const grad = ctx.createLinearGradient(x, y, x, y + enemyHeight);
    grad.addColorStop(0, '#1565c0');
    grad.addColorStop(1, '#0d3475');
    ctx.fillStyle = grad;
    ctx.fillRect(x, y, enemyWidth, enemyHeight);

    ctx.fillStyle = '#a2c9f9';
    ctx.fillRect(x + 10, y + 10, enemyWidth - 20, enemyHeight / 3);

    // Wheels
    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.ellipse(x + 15, y + enemyHeight - 20, 8, 12, 0, 0, 2 * Math.PI);
    ctx.fill();

    ctx.beginPath();
    ctx.ellipse(x + enemyWidth - 15, y + enemyHeight - 20, 8, 12, 0, 0, 2 * Math.PI);
    ctx.fill();
  }

  // Draw power-ups
  function drawPowerUp(powerUp) {
    const x = lanesX[powerUp.lane] + (carWidth - powerUpSize) / 2;
    const y = powerUp.y;
    ctx.fillStyle = powerUp.type === 'shield' ? 'cyan' : 'gold';
    ctx.beginPath();
    ctx.arc(x + powerUpSize/2, y + powerUpSize/2, powerUpSize/2, 0, 2*Math.PI);
    ctx.fill();

    ctx.fillStyle = 'black';
    ctx.font = '20px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(powerUp.type === 'shield' ? 'S' : 'B', x + powerUpSize/2, y + powerUpSize/2);
  }

  // Update player car position (smooth lane switching)
  function updateCarPosition(){
    if(carX < lanesX[targetLane]){
      carX += 8;
      if(carX > lanesX[targetLane]) carX = lanesX[targetLane];
    } else if(carX > lanesX[targetLane]){
      carX -= 8;
      if(carX < lanesX[targetLane]) carX = lanesX[targetLane];
    }
  }

  // Spawn enemies randomly
  function spawnEnemy(){
    if(Math.random() < enemySpawnRate){
      const lane = Math.floor(Math.random() * lanesCount);
      enemyCars.push({
        lane,
        y: -enemyHeight,
      });
    }
  }

  // Spawn power-ups randomly
  function spawnPowerUp(){
    if(Math.random() < powerUpSpawnRate){
      const lane = Math.floor(Math.random() * lanesCount);
      const type = Math.random() < 0.5 ? 'shield' : 'boost';
      powerUps.push({
        lane,
        y: -powerUpSize,
        type,
      });
    }
  }

  // Check collisions with enemies
  function checkCollisions(){
    for(let i = 0; i < enemyCars.length; i++){
      let enemy = enemyCars[i];
      if(enemy.lane === currentLane){
        if(enemy.y + enemyHeight > carY && enemy.y < carY + carHeight){
          if(shieldActive){
            shieldActive = false;
            shieldTimer = 0;
            enemyCars.splice(i, 1);
            playSound(sounds.shieldOn);
            return false; // survived due to shield
          } else {
            return true; // collision => game over
          }
        }
      }
    }
    return false;
  }

  // Check collisions with power-ups
  function checkPowerUpCollisions(){
    for(let i = 0; i < powerUps.length; i++){
      let powerUp = powerUps[i];
      if(powerUp.lane === currentLane){
        if(powerUp.y + powerUpSize > carY && powerUp.y < carY + carHeight){
          if(powerUp.type === 'shield'){
            shieldActive = true;
            shieldTimer = 600; // 10 seconds at 60fps
          } else if(powerUp.type === 'boost'){
            speedBoostActive = true;
            speedBoostTimer = 600;
          }
          powerUps.splice(i, 1);
          playSound(sounds.powerUp);
          break;
        }
      }
    }
  }

  // Update game difficulty and enemy speed
  function updateDifficulty(){
    if(score > 0 && score % 20 === 0){
      enemySpeed += 0.1;
      if(enemySpawnRate < 0.02) enemySpawnRate += 0.001;
      if(powerUpSpawnRate < 0.008) powerUpSpawnRate += 0.0005;
      showLevelUpMessage();
    }
  }

  // Show level up message briefly
  function showLevelUpMessage(){
    levelUpMessage.style.display = 'block';
    setTimeout(() => {
      levelUpMessage.style.display = 'none';
    }, 2000);
  }

  // Reset the game to initial state
  function resetGame(){
    enemyCars = [];
    powerUps = [];
    enemySpeed = 1.5;
    enemySpawnRate = 0.008;
    powerUpSpawnRate = 0.004;
    score = 0;
    scoreMultiplier = 1;
    gameOverFlag = false;
    shieldActive = false;
    shieldTimer = 0;
    speedBoostActive = false;
    speedBoostTimer = 0;
    currentLane = 1;
    targetLane = 1;
    carX = lanesX[currentLane];
    carBounce = 0;
    framesElapsed = 0;
    gameOverMessage.style.display = 'none';
    pauseOverlay.style.display = 'none';
    scoreDisplay.textContent = `Score: 0`;
  }

  // Pause the game
  function pauseGame(){
    paused = true;
    isPlaying = false;
    pauseOverlay.textContent = 'Paused';
    pauseOverlay.style.display = 'block';
    sounds.backgroundMusic.pause();
    playPauseBtn.textContent = 'Play';
  }

  // Resume game from pause
  function resumeGame(){
    paused = false;
    isPlaying = true;
    pauseOverlay.style.display = 'none';
    if(!muted) sounds.backgroundMusic.play();
    playPauseBtn.textContent = 'Pause';
    requestAnimationFrame(gameLoop);
  }

  // Start the game with countdown
  function startGame(){
    if(isPlaying) return;
    if(gameOverFlag) resetGame();

    // Countdown
    let countdown = 3;
    pauseOverlay.style.display = 'block';

    function countdownTick(){
      if(countdown > 0){
        pauseOverlay.textContent = `Starting in ${countdown}...`;
        playSound(sounds.countdownBeep);
        countdown--;
        setTimeout(countdownTick, 1000);
      } else {
        pauseOverlay.style.display = 'none';
        isPlaying = true;
        playPauseBtn.textContent = 'Pause';
        playSound(sounds.gameStart);
        sounds.backgroundMusic.play();
        requestAnimationFrame(gameLoop);
      }
    }
    countdownTick();
  }

  // Game over function
  function gameOver(){
    gameOverFlag = true;
    isPlaying = false;
    gameOverMessage.style.display = 'block';
    pauseOverlay.style.display = 'none';
    playPauseBtn.textContent = 'Retry';
    sounds.backgroundMusic.pause();
    playSound(sounds.gameOver);

    if(score > highScore){
      highScore = Math.floor(score);
      highScoreDisplay.textContent = `High Score: ${highScore}`;
      try {
        localStorage.setItem('carGameHighScore', highScore);
      } catch(e){}
    }
  }

  // Update all positions and game logic
  function update(){
    if(paused || gameOverFlag) return;

    framesElapsed++;

    if(leftPressed){
      if(targetLane > 0){
        targetLane--;
        playSound(sounds.leftRight);
        leftPressed = false;
      }
    } else if(rightPressed){
      if(targetLane < lanesCount - 1){
        targetLane++;
        playSound(sounds.leftRight);
        rightPressed = false;
      }
    }

    updateCarPosition();

    // Move enemy cars
    enemyCars.forEach(enemy => {
      enemy.y += enemySpeed * (speedBoostActive ? 1.5 : 1);
    });
    // Remove off-screen enemies
    enemyCars = enemyCars.filter(enemy => enemy.y < canvas.height + enemyHeight);

    // Move power-ups
    powerUps.forEach(powerUp => {
      powerUp.y += enemySpeed * (speedBoostActive ? 1.5 : 1);
    });
    // Remove off-screen power-ups
    powerUps = powerUps.filter(powerUp => powerUp.y < canvas.height + powerUpSize);

    // Spawn new enemies and power-ups
    spawnEnemy();
    spawnPowerUp();

    // Check collisions
    if(checkCollisions()){
      gameOver();
    }

    checkPowerUpCollisions();

    // Update power-up timers
    if(shieldActive){
      shieldTimer--;
      if(shieldTimer <= 0) shieldActive = false;
    }
    if(speedBoostActive){
      speedBoostTimer--;
      if(speedBoostTimer <= 0) speedBoostActive = false;
    }

    // Increase score
    score += 0.05 * scoreMultiplier;

    // Increase multiplier gradually (max 3)
    if(framesElapsed % 600 === 0 && scoreMultiplier < maxMultiplier){
      scoreMultiplier += 0.5;
    }

    // Increase difficulty every 20 points (rounded)
    if(Math.floor(score) > 0 && Math.floor(score) % 20 === 0){
      updateDifficulty();
    }

    // Car bounce and wheel rotation for animation
    carBounce += 0.3;
    wheelRotation += 0.3;

    // Update score display
    scoreDisplay.textContent = `Score: ${Math.floor(score)}`;
  }

  // Draw everything on canvas
  function draw(){
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    drawRoad();

    enemyCars.forEach(drawEnemyCar);
    powerUps.forEach(drawPowerUp);
    drawCar();
  }

  // Main game loop
  function gameLoop(){
    if(!isPlaying) return;

    update();
    draw();

    requestAnimationFrame(gameLoop);
  }

  // Initialize game state
  resetGame();

</script>
</body>
</html>
